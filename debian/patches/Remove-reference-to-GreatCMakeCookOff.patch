From: Ole Streicher <olebole@debian.org>
Date: Sat, 8 Oct 2016 14:43:07 +0200
Subject: Remove reference to GreatCMakeCookOff

GreateCMakeCookOff is not part of Debian, but some scripts are required for
sopt. They are included with this patch.
See https://bugs.debian.org/832748 for a discussion about getting
GreatCMakeCookOff into Debian.

URL of GreatCMakeCookOff is https://github.com/UCL/GreatCMakeCookOff
---
 CMakeLists.txt                                     |  25 +-
 cmake_files/GreatCMakeCookOff/AddCatchTest.cmake   | 112 ++++++
 .../GreatCMakeCookOff/CachedVariables.cmake        |  25 ++
 cmake_files/GreatCMakeCookOff/ChangeRootPath.cmake |  20 ++
 .../GreatCMakeCookOff/EnvironmentScript.cmake      | 126 +++++++
 cmake_files/GreatCMakeCookOff/FilterList.cmake     |  20 ++
 cmake_files/GreatCMakeCookOff/LICENSE              |  20 ++
 cmake_files/GreatCMakeCookOff/PackageLookup.cmake  | 377 +++++++++++++++++++++
 .../GreatCMakeCookOff/TargetCopyFiles.cmake        | 134 ++++++++
 cmake_files/GreatCMakeCookOff/Utilities.cmake      |  58 ++++
 cmake_files/GreatCMakeCookOff/localbash.in.sh      |  36 ++
 cmake_files/PassonVariables.cmake                  |  51 +++
 12 files changed, 989 insertions(+), 15 deletions(-)
 create mode 100644 cmake_files/GreatCMakeCookOff/AddCatchTest.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/CachedVariables.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/ChangeRootPath.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/EnvironmentScript.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/FilterList.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/LICENSE
 create mode 100644 cmake_files/GreatCMakeCookOff/PackageLookup.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/TargetCopyFiles.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/Utilities.cmake
 create mode 100644 cmake_files/GreatCMakeCookOff/localbash.in.sh
 create mode 100644 cmake_files/PassonVariables.cmake

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7600912..25eb995 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,21 +3,16 @@ project(Sopt CXX)
 
 # Location of extra cmake includes for the project
 list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_files)
-# Downloads and installs GreatCMakeCookOff
-# It contains a number of cmake recipes
-include(LookUp-GreatCMakeCookOff)
+list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_files/GreatCMakeCookOff)
 
-# Version and git hash id
-include(VersionAndGitRef)
-set_version(2.0.0)
-get_gitref()
+set(Sopt_VERSION 2.0.0)
 
-option(tests          "Enable testing"                         on)
-option(python         "Enable python"                          on)
-option(benchmarks     "Enable benchmarking"                    on)
-option(examples       "Enable Examples"                        on)
+option(tests          "Enable testing"                         off)
+option(python         "Enable python"                          off)
+option(benchmarks     "Enable benchmarking"                    off)
+option(examples       "Enable Examples"                        off)
 option(logging        "Enable logging"                         on)
-option(regressions    "Enable regressions"                     on)
+option(regressions    "Enable regressions"                     off)
 option(openmp         "Enable OpenMP"                          on)
 option(archer         "Compiling on ARCHER"                    off)
 
@@ -29,12 +24,12 @@ if(tests)
 endif()
 
 # Add c++11 stuff
-include(AddCPP11Flags)
-include(CheckCXX11Features)
+set(CXX11_FLAGS "${CXX11_FLAGS} -std=gnu++11")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX11_FLAGS}")
+set(PROJECT_USES_CPP11 True CACHE INTERNAL "Uses c++11.")
 if(tests AND python)
   include(AddPyTest)
 endif()
-cxx11_feature_check(REQUIRED unique_ptr nullptr override constructor_delegate)
 include(compilations)
 
 # search/install dependencies
diff --git a/cmake_files/GreatCMakeCookOff/AddCatchTest.cmake b/cmake_files/GreatCMakeCookOff/AddCatchTest.cmake
new file mode 100644
index 0000000..177612b
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/AddCatchTest.cmake
@@ -0,0 +1,112 @@
+# Function to create a common main
+function(common_catch_main)
+  if(TARGET common_catch_main_object)
+    return()
+  endif()
+  file(WRITE "${CMAKE_BINARY_DIR}/common_catch_main.cc"
+    "#define CATCH_CONFIG_MAIN\n"
+    "#include \"catch.hpp\"\n"
+  )
+  add_library(common_catch_main_object OBJECT "${CMAKE_BINARY_DIR}/common_catch_main.cc")
+  if(CATCH_INCLUDE_DIR)
+    target_include_directories(common_catch_main_object PRIVATE ${CATCH_INCLUDE_DIR})
+  endif()
+endfunction()
+
+# A function to create a test, once a an executable exists
+function(add_catch_test_with_seed testname testexec seed)
+  cmake_parse_arguments(catch "NOCATCHLABEL" "WORKING_DIRECTORY" "LABELS;ARGUMENTS" ${ARGN})
+
+  unset(EXTRA_ARGS)
+  if(catch_WORKING_DIRECTORY)
+    set(EXTRA_ARGS WORKING_DIRECTORY ${catch_WORKING_DIRECTORY})
+  endif()
+  set(arguments ${catch_ARGUMENTS})
+  if(NOT "${seed}" STREQUAL "")
+    list(APPEND arguments --rng-seed ${seed})
+  else()
+    list(APPEND arguments --rng-seed time)
+  endif()
+
+  if(CATCH_JUNIT)
+    add_test(NAME ${testname}
+      COMMAND ${testexec}
+          ${arguments}
+          -r junit
+          -o ${PROJECT_BINARY_DIR}/Testing/${testname}.xml
+    )
+  else()
+    add_test(NAME ${testname} COMMAND ${testexec} ${arguments} ${EXTRA_ARGS})
+  endif()
+
+  if(NOT catch_NOCATCHLABEL)
+    list(APPEND catch_LABELS catch)
+  endif()
+  set_tests_properties(${testname} PROPERTIES LABELS "${catch_LABELS}")
+endfunction()
+
+# Then adds a function to create a test
+function(add_catch_test testname)
+  cmake_parse_arguments(catch
+    "NOMAIN;NOTEST;NOCATCHLABEL"
+    "SEED;WORKING_DIRECTORY;COMMON_MAIN;PRECOMMAND"
+    "LIBRARIES;DEPENDS;INCLUDES;LABELS;ARGUMENTS"
+    ${ARGN}
+  )
+
+  # Source deduce from testname if possible
+  unset(source)
+  if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${testname}.cc")
+    set(source ${testname}.cc)
+  elseif(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${testname}.cpp")
+    set(source ${testname}.cpp)
+  elseif("${catch_UNPARSED_ARGUMENTS}" STREQUAL "")
+    message(FATAL_ERROR "No source given or found for ${testname}")
+  endif()
+
+  # By default, uses a common main function for all, compiled once
+  # We create here
+  if(catch_NOMAIN)
+    add_executable(test_${testname} ${source} ${catch_UNPARSED_ARGUMENTS})
+  elseif(catch_COMMON_MAIN)
+    add_executable(test_${testname}
+      ${source} $<TARGET_OBJECTS:${catch_COMMON_MAIN}> ${catch_UNPARSED_ARGUMENTS})
+  else()
+    common_catch_main()
+    add_executable(test_${testname}
+      ${source} $<TARGET_OBJECTS:common_catch_main_object> ${catch_UNPARSED_ARGUMENTS})
+  endif()
+
+  if(catch_LIBRARIES)
+    target_link_libraries(test_${testname} ${catch_LIBRARIES})
+  endif()
+  if(CATCH_INCLUDE_DIR)
+    target_include_directories(test_${testname} PRIVATE ${CATCH_INCLUDE_DIR})
+  endif()
+  if(catch_INCLUDES)
+    target_include_directories(test_${testname} PRIVATE ${catch_INCLUDES})
+  endif()
+  if(catch_DEPENDS)
+    add_dependencies(test_${testname} ${catch_DEPENDS})
+  endif()
+  if(TARGET lookup_dependencies)
+    add_dependencies(test_${testname} lookup_dependencies)
+  endif()
+
+  if(catch_NOCATCHLABEL)
+    set(catch_NOCATCHLABEL "NOCATCHLABEL")
+  else()
+    unset(catch_NOCATCHLABEL)
+  endif()
+  set(test_command test_${testname})
+  if(catch_PRECOMMAND)
+    set(test_command "${catch_PRECOMMAND} ${test_command}")
+  endif()
+  if(NOT catch_NOTEST)
+    add_catch_test_with_seed(
+      test_${testname} "test_${testname}" "${catch_SEED}" ${catch_UNPARSED_ARGUMENTS}
+      ${catch_NOCATCHLABEL} WORKING_DIRECTORY ${catch_WORKING_DIRECTORY}
+      LABELS ${catch_LABELS} ARGUMENTS ${catch_ARGUMENTS}
+    )
+  endif()
+endfunction()
diff --git a/cmake_files/GreatCMakeCookOff/CachedVariables.cmake b/cmake_files/GreatCMakeCookOff/CachedVariables.cmake
new file mode 100644
index 0000000..88fc41b
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/CachedVariables.cmake
@@ -0,0 +1,25 @@
+# Creates list of cached variables as command-line arguments
+function(cached_variables OUTVAR PATTERN)
+    get_cmake_property(variables CACHE_VARIABLES)
+    set(result)
+    foreach(variable ${variables})
+        if(${variable} AND variable MATCHES "${PATTERN}")
+            list(APPEND result "-D${variable}=\"${${variable}}\"")
+        endif()
+    endforeach()
+    set(${OUTVAR} ${result} PARENT_SCOPE)
+endfunction()
+
+#Â Deletes variables that match a pattern
+function(delete_variables)
+    get_cmake_property(variables CACHE_VARIABLES)
+    foreach(variable ${variables})
+        if(${variable})
+            foreach(PATTERN ${ARGN})
+                if(variable MATCHES "${PATTERN}")
+                    unset(${variable} CACHE)
+                endif()
+            endforeach()
+        endif()
+    endforeach()
+endfunction()
diff --git a/cmake_files/GreatCMakeCookOff/ChangeRootPath.cmake b/cmake_files/GreatCMakeCookOff/ChangeRootPath.cmake
new file mode 100644
index 0000000..b2b3f8f
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/ChangeRootPath.cmake
@@ -0,0 +1,20 @@
+# Changes/unchanges the root path
+# Makes it possible to look for packages stricly inside the root
+macro(_set_root_path PATH TYPE)
+    foreach(save MODE_PACKAGE MODE_INCLUDE MODE_PROGRAM MODE_LIBRARY)
+        set(_save_root_path_${save} ${CMAKE_FIND_ROOT_PATH_${save}})
+        set(CMAKE_FIND_ROOT_PATH_${save} ${TYPE})
+    endforeach()
+    set(_save_root_path "${CMAKE_FIND_ROOT_PATH}")
+    set(CMAKE_FIND_ROOT_PATH "${PATH}")
+endmacro()
+
+# Unchanges the root path
+macro(_unset_root_path)
+    foreach(save MODE_PACKAGE MODE_INCLUDE MODE_PROGRAM MODE_LIBRARY)
+        set(CMAKE_FIND_ROOT_PATH_${save} ${_save_root_path_${save}})
+    endforeach()
+    set(CMAKE_FIND_ROOT_PATH "${_save_root_path}")
+endmacro()
+
+
diff --git a/cmake_files/GreatCMakeCookOff/EnvironmentScript.cmake b/cmake_files/GreatCMakeCookOff/EnvironmentScript.cmake
new file mode 100644
index 0000000..88c3047
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/EnvironmentScript.cmake
@@ -0,0 +1,126 @@
+# Scripts that modify LD_LIBRARY_PATH and such
+
+#Â Adds a single path to a path-file
+function(_add_to_a_path_single THISFILE path)
+    if("${path}" STREQUAL "" OR "${path}" MATCHES "NOTFOUND")
+        return()
+    endif()
+    # If quacks like a library, get directory where it resides
+    get_filename_component(extension "${path}" EXT)
+    if("${extension}" MATCHES "\\.so.*" OR "${extension}" MATCHES "\\.dylib")
+        get_filename_component(path "${path}" PATH)
+    elseif("${extension}" MATCHES "\\.a")
+        return() #Â Archive are not dynamic, no need to add to rpath.
+    endif()
+    # Makes it an absolute path
+    get_filename_component(path "${path}" ABSOLUTE)
+    # Add to path file if not there yet
+    if(NOT EXISTS "${THISFILE}")
+        file(WRITE "${THISFILE}" "${path}\n")
+    else()
+        file(STRINGS "${THISFILE}" ALLPATHS)
+        list(FIND ALLPATHS "${path}" INDEX)
+        if(INDEX EQUAL -1)
+            file(APPEND "${THISFILE}" "${path}\n")
+        endif()
+    endif()
+endfunction()
+#Â Adds many paths to a path file
+function(_add_to_a_path THISFILE)
+    foreach(path ${ARGN})
+        _add_to_a_path_single("${THISFILE}" "${path}")
+    endforeach()
+endfunction()
+
+function(add_to_ld_path)
+    unset(ldpaths)
+    foreach(directory ${ARGN})
+        get_filename_component(directory "${directory}" ABSOLUTE)
+        if(NOT directory MATCHES "^\\/System\\/")
+            list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES
+                "${directory}" is_system_dir)
+            if("${is_system_dir}" STREQUAL "-1")
+                list(APPEND ldpaths "${directory}")
+            endif()
+        endif()
+    endforeach()
+    _add_to_a_path("${PROJECT_BINARY_DIR}/paths/ldpaths" ${ldpaths})
+endfunction()
+function(add_to_python_path)
+    _add_to_a_path("${PROJECT_BINARY_DIR}/paths/pypaths.pth" ${ARGN})
+endfunction()
+
+# Gets list of eggs in given directories
+function(_get_python_eggs OUTVAR)
+    unset(patterns)
+    foreach(directory ${ARGN})
+        if(NOT "${directory}" MATCHES ".*egg")
+            list(APPEND patterns "${directory}/*.egg")
+        else()
+            list(APPEND patterns "${directory}")
+        endif()
+    endforeach()
+    if(patterns)
+        file(GLOB directories ${patterns})
+        set(${OUTVAR} ${directories} PARENT_SCOPE)
+    endif()
+endfunction()
+
+# Add eggy directories to python path
+function(add_python_eggs)
+    cmake_parse_arguments(apeg "" "" "EXCLUDE;INCLUDE" ${ARGN})
+    _get_python_eggs(included_eggs ${apeg_UNPARSED_ARGUMENTS} ${apeg_INCLUDE})
+    _get_python_eggs(excluded_eggs ${apeg_EXCLUDE})
+    if(excluded_eggs)
+        list(REMOVE_ITEM included_eggs ${excluded_eggs})
+    endif()
+    add_to_python_path(${included_eggs})
+endfunction()
+
+if(NOT UNIX)
+    function(create_environment_script caller location)
+        message(FATAL_ERROR "Environment scripts not implemented "
+            "on non-UNIX systems")
+    endfunction()
+    return()
+endif()
+
+get_filename_component(_PATH_TO_LOCALBASH_IN
+    "${CMAKE_CURRENT_LIST_DIR}/localbash.in.sh"
+    ABSOLUTE
+)
+find_program(BASH_EXECUTABLE bash)
+find_program(ENV_EXECUTABLE env)
+include(CMakeParseArguments)
+
+function(create_environment_script)
+    cmake_parse_arguments(env 
+        "PYTHON"
+        "SCRIPT;PATH;EXECUTABLE;WORKING_DIRECTORY"
+        "" ${ARGN}
+    )
+    if(NOT env_PATH)
+        set(env_PATH "${CMAKE_CURRENT_BINARY_DIR}/envscript.sh")
+    endif()
+    if(NOT env_EXECUTABLE)
+        set(env_EXECUTABLE "")
+    endif()
+    # used in the configured script: if set, modifies python path
+    if(NOT env_PYTHON)
+        set(env_PYTHON "")
+    endif()
+    if(NOT env_SCRIPT)
+        set(env_SCRIPT "${_PATH_TO_LOCALBASH_IN}")
+    endif()
+
+    get_filename_component(filename "${env_PATH}" NAME)
+    get_filename_component(directory "${env_PATH}" PATH)
+    configure_file("${env_SCRIPT}"
+        "${PROJECT_BINARY_DIR}/CMakeFiles/${filename}"
+        @ONLY
+    )
+    file(COPY "${PROJECT_BINARY_DIR}/CMakeFiles/${filename}"
+        DESTINATION "${directory}"
+        FILE_PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
+    )
+endfunction()
diff --git a/cmake_files/GreatCMakeCookOff/FilterList.cmake b/cmake_files/GreatCMakeCookOff/FilterList.cmake
new file mode 100644
index 0000000..fd40430
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/FilterList.cmake
@@ -0,0 +1,20 @@
+function(filter_list output input)
+    unset(result)
+    foreach(filename ${${input}})
+        foreach(pattern ${ARGN})
+            if("${filename}" MATCHES "${pattern}")
+                list(APPEND result "${filename}")
+            endif()
+        endforeach()
+    endforeach()
+    set(${output} ${result} PARENT_SCOPE)
+endfunction()
+
+function(split_list haves havenots input)
+    filter_list(_haves ${input} ${ARGN})
+    set(_havenots ${${input}})
+    list(REMOVE_ITEM _havenots ${_haves})
+    set(${haves} ${_haves} PARENT_SCOPE)
+    set(${havenots} ${_havenots} PARENT_SCOPE)
+endfunction()
+
diff --git a/cmake_files/GreatCMakeCookOff/LICENSE b/cmake_files/GreatCMakeCookOff/LICENSE
new file mode 100644
index 0000000..8dbb759
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/LICENSE
@@ -0,0 +1,20 @@
+The MIT License (MIT)
+
+Copyright (c) 2013 University College London
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/cmake_files/GreatCMakeCookOff/PackageLookup.cmake b/cmake_files/GreatCMakeCookOff/PackageLookup.cmake
new file mode 100644
index 0000000..132006b
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/PackageLookup.cmake
@@ -0,0 +1,377 @@
+#Â Adds the ability to "look-up" a package, e.g. find it on the system,
+# or fetch it from the web and install it.
+# See https://github.com/UCL/GreatCMakeCookOff/wiki for information
+
+include(ChangeRootPath)
+
+# Sets location where external project are included
+if(NOT EXTERNAL_ROOT)
+  set(EXTERNAL_ROOT "${CMAKE_BINARY_DIR}/external")
+endif(NOT EXTERNAL_ROOT)
+# Makes sure external projects are found by cmake
+list(FIND CMAKE_PREFIX_PATH "${EXTERNAL_ROOT}" has_external_root)
+if(has_external_root EQUAL -1)
+    list(APPEND CMAKE_PREFIX_PATH "${EXTERNAL_ROOT}")
+endif()
+
+include(CachedVariables)
+include(Utilities)
+add_to_envvar(PKG_CONFIG_PATH "${EXTERNAL_ROOT}/lib/pkgconfig" PREPEND OS UNIX)
+add_to_envvar(PKG_CONFIG_PATH
+    "${EXTERNAL_ROOT}/lib64/pkgconfig" PREPEND OS UNIX)
+add_to_envvar(LD_LIBRARY_PATH "${EXTERNAL_ROOT}/lib" PREPEND OS UNIX)
+add_to_envvar(LD_LIBRARY_PATH "${EXTERNAL_ROOT}/lib64" PREPEND OS UNIX)
+add_to_envvar(DYLD_LIBRARY_PATH "${EXTERNAL_ROOT}/lib" PREPEND OS APPLE)
+add_to_envvar(DYLD_LIBRARY_PATH "${EXTERNAL_ROOT}/lib64" PREPEND OS APPLE)
+
+# Adds a target for all external projects, so they can be made prior to others.
+if(NOT TARGET lookup_dependencies)
+    add_custom_target(lookup_dependencies ALL)
+endif()
+
+include(FindPackageHandleStandardArgs)
+include(ExternalProject)
+
+function(_find_lookup_recipe package OUTVAR)
+    foreach(path ${CMAKE_MODULE_PATH})
+      list(APPEND cmake_paths "${path}/${package}")
+    endforeach()
+    set(LOOKUP_RECIPE LOOKUP_RECIPE-NOTFOUND)
+    foreach(filename ${package}-lookup.cmake LookUp${package}.cmake)
+        find_path(LOOKUP_RECIPE ${filename}
+            PATHS ${CMAKE_LOOKUP_PATH} ${CMAKE_MODULE_PATH} ${cmake_paths}
+            NO_DEFAULT_PATH
+        )
+        if(LOOKUP_RECIPE)
+            set(${OUTVAR}_DIR "${LOOKUP_RECIPE}" PARENT_SCOPE)
+            set(${OUTVAR}_FILE "${LOOKUP_RECIPE}/${filename}" PARENT_SCOPE)
+            return()
+        endif()
+    endforeach()
+
+    if(NOT LOOKUP_RECIPE)
+        find_path(LOOKUP_RECIPE lookup.cmake
+            PATHS ${cmake_paths}
+            NO_DEFAULT_PATH
+        )
+    endif()
+
+    if(LOOKUP_RECIPE)
+      set(${OUTVAR}_DIR "${LOOKUP_RECIPE}" PARENT_SCOPE)
+      set(${OUTVAR}_FILE "${LOOKUP_RECIPE}/lookup.cmake" PARENT_SCOPE)
+    endif()
+endfunction()
+
+macro(_get_sane_name name OUTVAR)
+    string(REGEX REPLACE "\\-" "_" ${OUTVAR} "${name}")
+endmacro()
+
+macro(_find_package_for_lookup package REQUIRED QUIET DOWNLOAD_BY_DEFAULT CHECK)
+    string(TOUPPER "${package}" PACKAGE)
+    set(recursive FALSE)
+    _get_sane_name(${package} SANENAME)
+    if(${SANENAME}_RECURSIVE) # Called by recursive step
+        delete_package_variables(${package})
+        set(recursive TRUE)
+        if(${package}_NOFIND)
+            set(${package}_FOUND TRUE CACHE BOOL "")
+        endif()
+    endif()
+    # First try and find package (unless downloading by default)
+    set(dolook TRUE)
+    if(NOT recursive)
+      if("${DOWNLOAD_BY_DEFAULT}" STREQUAL "TRUE")
+        set(dolook FALSE)
+      else()
+        set(dolook TRUE)
+      endif()
+      if(CHECK)
+          set(do_rootchange TRUE)
+      endif()
+    endif()
+    # Figure out whether to add REQUIRED and QUIET keywords
+    set(required "")
+    if(recursive AND REQUIRED)
+        set(required REQUIRED)
+    endif()
+    unset(quiet)
+    if(QUIET OR (NOT QUIET AND NOT recursive))
+        set(quiet QUIET)
+    endif()
+    if(dolook OR do_rootchange)
+        if(do_rootchange)
+            _set_root_path("${EXTERNAL_ROOT}" ONLY)
+        else() 
+            # Set external root as first place to look
+            set(_SAVE_CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH})
+            list(INSERT CMAKE_PREFIX_PATH 0 "${EXTERNAL_ROOT}")
+        endif()
+        find_package(${package} ${ARGN} ${required} ${quiet})
+        if(do_rootchange)
+            _unset_root_path()
+            unset(do_rootchange)
+            if(${PACKAGE}_FOUND OR ${package}_FOUND)
+                message(STATUS "Found ${package} in external "
+                    "projects directory ${EXTERNAL_ROO}")
+            endif()
+        else()
+            set(CMAKE_PREFIX_PATH ${_SAVE_CMAKE_PREFIX_PATH})
+            if(NOT QUIET AND (${PACKAGE}_FOUND OR ${package}_FOUND))
+                message(STATUS "Found ${package}")
+            endif()
+        endif()
+    endif()
+endmacro()
+
+macro(_perform_actual_lookup package)
+    _find_lookup_recipe(${package} ${package}_LOOKUP_RECIPE)
+    if(NOT ${package}_LOOKUP_RECIPE_FILE)
+        #Â Checks if package is required
+        set(msg "Could not find recipe to lookup "
+                "${package} -- ${${package}_RECIPE_DIR}")
+        if(${package}_REQUIRED)
+            message(FATAL_ERROR ${msg})
+        elseif(NOT ${package}_QUIET)
+            message(STATUS ${msg})
+        endif()
+    else()
+        if(NOT ${package}_QUIET)
+            if(${package}_FOUND)
+                message(STATUS
+                    "${package} is built locally as an external project")
+            elseif(NOT ${package}_DOWNLOAD_BY_DEFAULT)
+                message(STATUS
+                    "Will attempt to download and install ${package}")
+            else()
+                message(STATUS "Will download, build,"
+                   " and install a local version of ${package}")
+            endif()
+        endif()
+        set(CURRENT_LOOKUP_DIRECTORY "${${package}_LOOKUP_RECIPE_DIR}")
+        if(NOT ${package}_LOOKUP_PACKAGE_INCLUSION_GUARD)
+          include(${${package}_LOOKUP_RECIPE_FILE})
+          set(${package}_LOOKUP_PACKAGE_INCLUSION_GUARD TRUE)
+        endif()
+        unset(CURRENT_LOOKUP_DIRECTORY)
+        set(${package}_LOOKUP_BUILD ${${package}_KEEP} CACHE BOOL
+            "Whether package is obtained from a lookup build"
+            FORCE
+        )
+        if(TARGET ${package})
+            add_dependencies(lookup_dependencies ${package})
+        elseif(TARGET Lookup-${package})
+            add_dependencies(lookup_dependencies Lookup-${package})
+        elseif(TARGET LookUp-${package})
+            add_dependencies(lookup_dependencies LookUp-${package})
+        endif()
+    endif()
+endmacro()
+
+# Returns name of given hook and package in hook_script variable
+function(get_lookup_hookscript_name hook package)
+    string(TOUPPER "${hook}" hook)
+    if("${hook}" STREQUAL "POST_LOOKUP")
+        set(filename "${EXTERNAL_ROOT}/hooks/post_lookup/${package}.cmake")
+    elseif("${hook}" STREQUAL "INSTALL")
+        set(filename "${EXTERNAL_ROOT}/hooks/install/${package}.cmake")
+    else()
+        set(hooks POST_LOOKUP INSTALL)
+        message(FATAL_ERROR
+            "Hook argument(${hook}) should be one of ${hooks}.")
+    endif()
+    list(LENGTH ARGN nargs)
+    set(variable hook_script)
+    if(NOT nargs EQUAL 0)
+        list(GET ARGN 0 variable)
+    endif()
+    set(${variable} "${filename}" PARENT_SCOPE)
+endfunction()
+
+macro(delete_package_variables package)
+    string(TOUPPER "${package}" PACKAGE)
+    delete_variables(
+       "LOOKUP_${package}" "LOOKUP_${PACKAGE}"
+       "^${package}_LIBRAR.*" "^${PACKAGE}_LIBRAR.*"
+       "^${package}_.*_LIBRAR.*" "^${PACKAGE}_.*_LIBRAR.*"
+       "^${package}_INCLUD.*" "^${PACKAGE}_INCLUD.*"
+       "^${package}_.*_INCLUD.*" "^${PACKAGE}_.*_INCLUD.*"
+       "^${package}_FOUND" "^${PACKAGE}_FOUND"
+       "^${package}_.*_FLAGS" "^${PACKAGE}_.*_FLAGS"
+       "^${package}_.*CXXFLAGS" "^${PACKAGE}_.*CXXFLAGS"
+       "^${package}_.*CFLAGS" "^${PACKAGE}_.*CFLAGS"
+       "^${package}_.*F9.FLAGS" "^${PACKAGE}_.*F9.FLAGS"
+    )
+    unset(${package}_FOUND)
+    unset(${PACKAGE}_FOUND)
+endmacro()
+
+#Â Looks for a lookup package file and includes it.
+macro(lookup_package package)
+    # include potential hooks
+    if(${package}_BUILT_AS_EXTERNAL_PROJECT)
+        get_lookup_hookscript_name(post_lookup ${package})
+        if(EXISTS "${hook_script}")
+            include("${hook_script}")
+        endif()
+    endif()
+
+    string(TOUPPER "${package}" PACKAGE)
+    cmake_parse_arguments(${package}
+        "DOWNLOAD_BY_DEFAULT;REQUIRED;QUIET;KEEP;NOFIND;CHECK_EXTERNAL"
+        ""
+        "ARGUMENTS;COMPONENTS"
+        ${ARGN}
+    )
+    # Set explicitly to TRUE or FALSE to simplify setting
+    # ${package}_LOOKUP_BUILD
+    if(${package}_KEEP)
+        set(${package}_KEEP TRUE)
+    else()
+        set(${package}_KEEP FALSE)
+    endif()
+    if(NOT ${package}_REQUIRED)
+      set(${package}_REQUIRED FALSE)
+    endif()
+    if(NOT ${package}_QUIET)
+      set(${package}_QUIET FALSE)
+    endif()
+    if(NOT ${package}_DOWNLOAD_BY_DEFAULT)
+      set(${package}_DOWNLOAD_BY_DEFAULT FALSE)
+    else()
+      set(${package}_DOWNLOAD_BY_DEFAULT TRUE)
+    endif()
+    if(NOT ${package}_CHECK_EXTERNAL)
+      set(${package}_CHECK_EXTERNAL FALSE)
+    endif()
+    # users can request to download the package explicitly on the command-line
+    if(LOOKUP_${package} OR LOOKUP_${PACKAGE})
+        set(${package}_DOWNLOAD_BY_DEFAULT TRUE)
+        delete_package_variables(${package})
+    endif()
+
+    # Reappends components
+    if(${package}_COMPONENTS)
+        list(APPEND ${package}_UNPARSED_ARGUMENTS COMPONENTS)
+        list(APPEND ${package}_UNPARSED_ARGUMENTS ${${package}_COMPONENTS})
+    endif()
+    # First try and locate package
+    _find_package_for_lookup(${package}
+        ${${package}_REQUIRED} ${${package}_QUIET}
+        ${${package}_DOWNLOAD_BY_DEFAULT} ${${package}_CHECK_EXTERNAL}
+        ${${package}_UNPARSED_ARGUMENTS}
+    )
+
+    # Sets lower and upper case versions.
+    # Otherwise some package will be registered as not found.
+    # This is a problem with changing cmake practices.
+    if(${PACKAGE}_FOUND AND NOT "${package}" STREQUAL "${PACKAGE}")
+        set(${package}_FOUND ${${PACKAGE}_FOUND})
+    endif()
+    if(${package}_FOUND AND ${package}_BUILT_AS_EXTERNAL_PROJECT)
+        get_lookup_hookscript_name(install ${package})
+        if(EXISTS "${hook_script}")
+            install(SCRIPT "${hook_script}")
+        endif()
+    endif()
+    # If package is not found, then look for a recipe to download and build it
+    if(NOT ${package}_FOUND OR ${package}_LOOKUP_BUILD OR ${package}_KEEP)
+        _perform_actual_lookup(${package})
+        # Sets a variable saying we are building this source externally
+        set(${package}_BUILT_AS_EXTERNAL_PROJECT TRUE CACHE INTERNAL
+            "${package} is the result of a local install")
+    endif()
+endmacro()
+
+
+# Makes target depend on external dependencies
+macro(depends_on_lookups TARGET)
+    add_dependencies(${TARGET} lookup_dependencies)
+endmacro()
+
+# Adds an external step to an external project to rerun cmake
+macro(add_recursive_cmake_step name)
+    cmake_parse_arguments(recursive
+        "NOCHECK" "FOUND_VAR;PACKAGE_NAME" "" ${ARGN})
+    if(recursive_PACKAGE_NAME)
+        set(recurse_name "${recursive_PACKAGE_NAME}")
+    else()
+        string(REGEX REPLACE "Look(u|U)p-?" "" recurse_name "${name}")
+    endif()
+    set(found_var ${recurse_name}_FOUND)
+    if(recursive_FOUND_VAR)
+        set(found_var ${recursive_FOUND_VAR})
+    endif()
+
+    # Only add recurse step if package not found already.
+    # Once the package has been found and configured,
+    # the locations and such should not change, so
+    # there is no need for a recursive cmake step.
+    if(NOT DEFINED ${found_var} OR NOT ${found_var})
+        _get_sane_name(${recurse_name} SANENAME)
+        set(cmakefile "${PROJECT_BINARY_DIR}/CMakeFiles/external")
+        set(cmakefile "${cmakefile}/${name}_recursive.cmake")
+        file(WRITE "${cmakefile}"
+          "set(CMAKE_PROGRAM_PATH \"${EXTERNAL_ROOT}/bin\" CACHE PATH \"\")\n"
+          "set(CMAKE_LIBRARY_PATH \"${EXTERNAL_ROOT}/lib\" CACHE PATH \"\")\n"
+          "set(CMAKE_INCLUDE_PATH "
+            "\"${EXTERNAL_ROOT}/include\" CACHE PATH \"\")\n"
+          "set(CMAKE_PREFIX_PATH \"${EXTERNAL_ROOT}\" CACHE PATH \"\")\n"
+          "set(${SANENAME}_RECURSIVE TRUE CACHE INTERNAL \"\")\n"
+        )
+        if(NOT recursive_NOCHECK)
+            file(APPEND "${cmakefile}"
+                "set(${SANENAME}_REQUIREDONRECURSE TRUE CACHE INTERNAL \"\")\n"
+            )
+        endif()
+        ExternalProject_Add_Step(
+            ${name} reCMake
+            COMMAND
+                ${CMAKE_COMMAND} -C "${cmakefile}"
+                    --no-varn-unused-cli "${CMAKE_SOURCE_DIR}"
+            WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
+            ${recursive_UNPARSED_ARGUMENTS}
+        )
+        if(${SANENAME}_REQUIREDONRECURSE)
+            if(NOT ${found_var} OR "${${found_var}}" STREQUAL "")
+                unset(${SANENAME}_REQUIREDONRECURSE CACHE)
+                message(FATAL_ERROR
+                    "[${name}] Could not be downloaded and installed"
+                )
+            endif()
+        endif()
+    endif()
+
+endmacro()
+
+# A script that is executed once a package has been built locally
+# This function should be called from the lookup recipe
+function(write_lookup_hook hook package)
+    cmake_parse_arguments(_wpls${package}
+        "APPEND" "SCRIPTNAME;CONFIGURE" "" ${ARGN})
+    if(_wpls${package}_APPEND AND _wpls${package}_CONFIGURE)
+        message(FATAL_ERROR "Only one of APPEND and CONFIGURE is valid")
+    endif()
+
+    # Sets filename. That's the only difference between hooks, in practice.
+    get_lookup_hookscript_name(${hook} ${package})
+    # Then write or append to file.
+    if(_wpls${package}_APPEND AND NOT _wpls${package}_CONFIGURE)
+        file(APPEND "${hook_script}" ${_wpls${package}_UNPARSED_ARGUMENTS})
+    elseif(NOT _wpls${package}_CONFIGURE)
+        file(WRITE "${hook_script}" ${_wpls${package}_UNPARSED_ARGUMENTS})
+    else()
+        configure_file("${_wpls${package}_CONFIGURE}" "${hook_script}" @ONLY)
+    endif()
+    if(_wpls${package}_SCRIPTNAME)
+        set(${_wpls${package}_SCRIPTNAME} "${hook_script}" PARENT_SCOPE)
+    endif()
+endfunction()
+
+# Avoids anoying cmake warning, by actually using the variables.
+# The will be if the appropriate find_* is used. But won't be otherwise.
+if(CMAKE_PROGRAM_PATH)
+endif()
+if(CMAKE_LIBRARY_PATH)
+endif()
+if(CMAKE_INCLUDE_PATH)
+endif()
diff --git a/cmake_files/GreatCMakeCookOff/TargetCopyFiles.cmake b/cmake_files/GreatCMakeCookOff/TargetCopyFiles.cmake
new file mode 100644
index 0000000..32c4377
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/TargetCopyFiles.cmake
@@ -0,0 +1,134 @@
+#Â Adds a target which simply copies files from one place to another.
+# See https://github.com/UCL/GreatCMakeCookOff/wiki for information
+include(CMakeParseArguments)
+
+function(add_copy_files FILECOPIER_TARGET)
+    cmake_parse_arguments(
+        FILECOPIER
+        "VERBOSE"
+        "DESTINATION;GLOB"
+        "REPLACE;FILES"
+        ${ARGN}
+    )
+
+    if(NOT TARGET "${FILECOPIER_TARGET}")
+        add_custom_target(${FILECOPIER_TARGET})
+    endif()
+    get_target_property(result ${FILECOPIER_TARGET} TYPE)
+    if(NOT FILECOPIER_DESTINATION)
+        set(destination ${CMAKE_CURRENT_BINARY_DIR})
+    else()
+        get_filename_component(destination "${FILECOPIER_DESTINATION}" ABSOLUTE)
+    endif()
+    if(NOT FILECOPIER_GLOB AND NOT FILECOPIER_FILES)
+        set(input_sources ${FILECOPIER_UNPARSED_ARGUMENTS})
+    elseif(FILECOPIER_GLOB AND FILECOPIER_FILES)
+        message(FATAL_ERROR "copy_files takes one of GLOB or FILES, not both")
+    elseif(FILECOPIER_FILES)
+        set(input_sources ${FILECOPIER_FILES})
+    else()
+        file(GLOB input_sources ${FILECOPIER_GLOB})
+    endif()
+
+    if(FILECOPIER_REPLACE)
+        list(LENGTH FILECOPIER_REPLACE replace_length)
+        if(NOT ${replace_length} EQUAL 2)
+            message(FATAL_ERROR "copy_files argument REPLACE takes two inputs")
+        endif()
+        list(GET FILECOPIER_REPLACE 0 PATTERN)
+        list(GET FILECOPIER_REPLACE 1 REPLACEMENT)
+    endif()
+
+    foreach(input ${input_sources})
+        get_filename_component(output ${input} NAME)
+        if(NOT "${FILECOPIER_REPLACE}" STREQUAL "")
+            string(REGEX REPLACE "${PATTERN}" "${REPLACEMENT}" output ${output})
+        endif()
+        set(output ${destination}/${output})
+        get_filename_component(input_abs "${input}" ABSOLUTE)
+        get_filename_component(output_abs "${output}" ABSOLUTE)
+        set(verbosity COMMENT "Copying ${input} to ${destination}")
+        if(NOT ${FILECOPIER_VERBOSE})
+            unset(verbosity)
+        endif()
+        if(NOT "${input_abs}" STREQUAL "${output_abs}")
+            add_custom_command(
+                TARGET ${FILECOPIER_TARGET}
+                PRE_BUILD
+                COMMAND ${CMAKE_COMMAND} -E copy_if_different
+                    ${input_abs} ${output_abs}
+                ${verbosity}
+                DEPENDS "${input}"
+            )
+       endif()
+    endforeach()
+endfunction()
+
+function(add_copy_directory dircopy_TARGET directory)
+    cmake_parse_arguments(dircopy
+        "VERBOSE" "DESTINATION;RELATIVE" "EXCLUDE;GLOB" ${ARGN})
+
+    get_filename_component(directory "${directory}" ABSOLUTE)
+    if(NOT TARGET ${dircopy_TARGET})
+        add_custom_target(${dircopy_TARGET})
+    endif()
+    if(NOT dircopy_GLOB)
+        set(dircopy_GLOB "*")
+    endif()
+    if(NOT dircopy_EXCLUDE)
+        unset(dircopy_EXCLUDE)
+    endif()
+    if(NOT dircopy_DESTINATION)
+        set(dircopy_DESTINATION "${CMAKE_CURRENT_BINARY_DIR}")
+    else()
+        get_filename_component(dircopy_DESTINATION "${dircopy_DESTINATION}" ABSOLUTE)
+    endif()
+    if(NOT dircopy_RELATIVE)
+        set(dircopy_RELATIVE "${directory}")
+    else()
+        get_filename_component(dircopy_RELATIVE "${dircopy_RELATIVE}" ABSOLUTE)
+    endif()
+
+    # Figure out globs for files that could be copied
+    unset(in_globs)
+    foreach(pattern ${dircopy_GLOB})
+        list(APPEND in_globs "${directory}/${pattern}")
+    endforeach()
+    # Figure out globs for files that won't be copied
+    unset(exclude_globs)
+    foreach(pattern ${dircopy_EXCLUDE})
+        list(APPEND exclude_globs "${directory}/${pattern}")
+    endforeach()
+
+    # Figure out files to copy
+    file(GLOB_RECURSE in_files RELATIVE "${dircopy_RELATIVE}" ${in_globs})
+    if(NOT "${exclude_globs}" STREQUAL "")
+        file(GLOB_RECURSE exclude_files RELATIVE "${dircopy_RELATIVE}" ${exclude_globs})
+        if(exclude_files)
+          list(REMOVE_ITEM in_files ${exclude_files})
+        endif()
+    endif()
+
+    # And do the copying
+    foreach(infile ${in_files})
+        set(output "${dircopy_DESTINATION}/${infile}")
+        set(input "${dircopy_RELATIVE}/${infile}")
+        get_filename_component(output_abs "${output}" ABSOLUTE)
+        get_filename_component(input_abs "${input}" ABSOLUTE)
+        set(verbosity COMMENT "Copying ${infile} to ${dircopy_DESTINATION}")
+        if(NOT ${dircopy_VERBOSE})
+            unset(verbosity)
+        endif()
+        if(NOT "${input_abs}" STREQUAL "${output_abs}")
+            add_custom_command(
+                TARGET ${dircopy_TARGET}
+                PRE_BUILD
+                COMMAND ${CMAKE_COMMAND} -E copy_if_different
+                    ${input_abs} ${output_abs}
+                ${verbosity}
+                DEPENDS "${input}"
+            )
+        endif()
+    endforeach()
+endfunction()
+
diff --git a/cmake_files/GreatCMakeCookOff/Utilities.cmake b/cmake_files/GreatCMakeCookOff/Utilities.cmake
new file mode 100644
index 0000000..13c784c
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/Utilities.cmake
@@ -0,0 +1,58 @@
+# Immediately creates a directory
+function(mkdir directory)
+    if(NOT EXISTS "${directory}")
+        execute_process(
+            COMMAND ${CMAKE_COMMAND} -E make_directory ${directory}
+            OUTPUT_QUIET
+        )
+    endif()
+endfunction()
+
+# Immediately creates a symbolic link between two files
+function(symlink FROM TO)
+    if(NOT EXISTS "${FROM}")
+        return()
+    endif()
+    if(EXISTS "${TO}")
+        return()
+    endif()
+    if(WIN32)
+        set(linkme mklink)
+        if(IS_DIRECTORY "${FROM}")
+          set(argument "/d")
+        else()
+          set(argument "")
+        endif()
+    else()
+        set(linkme "ln")
+        set(argument "-s")
+    endif()
+    get_filename_component(WD "${TO}" PATH)
+    get_filename_component(TO "${TO}" NAME)
+    execute_process(COMMAND ${linkme} ${argument} ${FROM} ${TO}
+        WORKING_DIRECTORY ${WD}
+    )
+endfunction()
+
+# Adds to a variety of environment variables
+function(add_to_envvar VARIABLE PATH)
+    include(CMakeParseArguments)
+    cmake_parse_arguments(envvar "PREPEND" "OS" "" ${ARGN})
+    if(envvar_OS AND NOT ${${envvar_OS}})
+        return()
+    endif()
+    if("$ENV{${VARIABLE}}" STREQUAL "")
+        set(separator "")
+    elseif(WIN32)
+        set(separator ";")
+    else()
+        set(separator ":")
+    endif()
+    if(envvar_PREPEND)
+        set(ENV{${VARIABLE}} "${PATH}${separator}$ENV{${VARIABLE}}")
+    else()
+        set(ENV{${VARIABLE}} "$ENV{${VARIABLE}}${separator}${PATH}")
+    endif()
+endfunction()
+
+
diff --git a/cmake_files/GreatCMakeCookOff/localbash.in.sh b/cmake_files/GreatCMakeCookOff/localbash.in.sh
new file mode 100644
index 0000000..3e5e66b
--- /dev/null
+++ b/cmake_files/GreatCMakeCookOff/localbash.in.sh
@@ -0,0 +1,36 @@
+#!@ENV_EXECUTABLE@ @BASH_EXECUTABLE@
+if [ -e @PROJECT_BINARY_DIR@/paths/ldpaths ]; then
+    add_to_ld() {
+        if [ -d "$1" ] && [[ ":$LD_LIBRARY_PATH:" != *":$1:"* ]]; then
+            LD_LIBRARY_PATH="${LD_LIBRARY_PATH:+"$LD_LIBRARY_PATH:"}$1"
+        fi
+        if [ -d "$1" ] && [[ ":$DYLD_FALLBACK_LIBRARY_PATH:" != *":$1:"* ]]; then
+            DYLD_FALLBACK_LIBRARY_PATH="${DYLD_FALLBACK_LIBRARY_PATH:+"$DYLD_FALLBACK_LIBRARY_PATH:"}$1"
+        fi
+    }
+    while read -r line; do
+       add_to_ld $line
+    done < @PROJECT_BINARY_DIR@/paths/ldpaths
+    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH
+    export DYLD_FALLBACK_LIBRARY_PATH=$DYLD_FALLBACK_LIBRARY_PATH
+fi
+if [ -e @PROJECT_BINARY_DIR@/paths/pypaths.pth ] && [ -n "@env_PYTHON@" ]; then
+    add_to_py() {
+      if [ -d "$1" ] && [[ ":$PYTHONPATH:" != *":$1:"* ]]; then
+        PYTHONPATH="${PYTHONPATH:+"$PYTHONPATH:"}$1"
+      fi
+    }
+    while read -r line; do
+       add_to_py $line
+    done < @PROJECT_BINARY_DIR@/paths/pypaths.pth
+    export PYTHONPATH=$PYTHONPATH
+fi
+export PATH=@PROJECT_BINARY_DIR@/external/bin:$PATH
+if [ -n "@env_WORKING_DIRECTORY@" ]; then
+    cd @env_WORKING_DIRECTORY@
+fi
+if [ -n "@env_EXECUTABLE@" ]; then
+    @env_EXECUTABLE@ "$@"
+else
+    eval $@
+fi
diff --git a/cmake_files/PassonVariables.cmake b/cmake_files/PassonVariables.cmake
new file mode 100644
index 0000000..6ebb989
--- /dev/null
+++ b/cmake_files/PassonVariables.cmake
@@ -0,0 +1,51 @@
+# A script to write cache variables to file
+# Makes it easy to include a subset of cached variables in external projects
+function(passon_variables PACKAGE)
+    include(CMakeParseArguments)
+    cmake_parse_arguments(passon
+        "APPEND;PUBLIC" "FILENAME" "PATTERNS;ALSOADD"
+        ${ARGN}
+    )
+    if(NOT passon_FILENAME AND EXTERNAL_ROOT)
+        set(passon_FILENAME "${EXTERNAL_ROOT}/src/${PACKAGE}.cmake")
+    elseif()
+        set(passon_FILENAME "${CMAKE_BINARY_DIR}/CMakeFiles/${PACKAGE}.cmake")
+    endif()
+    get_cmake_property(all_cached_variables CACHE_VARIABLES)
+    if(passon_PUBLIC)
+        set(oldvarlist ${all_cached_variables})
+        set(all_cached_variables "")
+        foreach(variable ${oldvarlist})
+            get_property(type CACHE ${variable} PROPERTY TYPE)
+            if(NOT "${type}" STREQUAL "INTERNAL")
+                list(APPEND all_cached_variables ${variable})
+            endif()
+        endforeach()
+    endif()
+    set(setters "")
+    foreach(variable ${all_cached_variables})
+        set(does_match False)
+        foreach(pattern ${passon_PATTERNS})
+            if(variable MATCHES "${pattern}")
+                set(does_match True)
+                break()
+            endif()
+        endforeach()
+        if(does_match)
+            get_property(type CACHE ${variable} PROPERTY TYPE)
+            get_property(help CACHE ${variable} PROPERTY HELPSTRING)
+            set(setters
+              "${setters}\nset(${variable} \"${${variable}}\" CACHE ${type} \"${help}\")"
+            )
+        endif()
+    endforeach()
+    if(NOT passon_APPEND)
+      file(WRITE "${passon_FILENAME}" "# pre-cached variables for ${PACKAGE}")
+    endif()
+    file(APPEND "${passon_FILENAME}"
+        "${setters}\n"
+        "\n# Explicitely added lines\n"
+        ${passon_ALSOADD}
+        "\n# End of passon_variables\n"
+    )
+endfunction()
